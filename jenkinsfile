pipeline {
    agent any

    environment {
        GIT_REPO = 'https://github.com/Nava200/branch-automation.git', pipeline {
    agent any

    environment {
        GIT_CREDENTIALS = 'github-automation'  // GitHub credentials
        REPOS = ['https://github.com/Nava200/branch-automation.git', 'https://github.com/Nava200/Getting-Started-Terraform.git']  // List of repositories
        BRANCHES_TO_ARCHIVE = ''
        BRANCHES_TO_DELETE = ''
    }

    stages {
        stage('Checkout Repositories') {
            steps {
                script {
                    // Iterate over each repository
                    REPOS.each { REPO ->
                        echo "Cloning repository: ${REPO}"
                        dir("repo-${REPO.hashCode()}") {  // Unique folder per repo
                            checkout scm: [
                                $class: 'GitSCM',
                                branches: [[name: 'origin/main']],
                                userRemoteConfigs: [[url: REPO, credentialsId: GIT_CREDENTIALS]]
                            ]
                        }
                    }
                }
            }
        }

        stage('Fetch and Identify Branches to Archive/Remove') {
            steps {
                script {
                    def archiveBranches = []
                    def deleteBranches = []

                    // Iterate over each repository to fetch branches and check conditions
                    REPOS.each { REPO ->
                        echo "Fetching all remote branches for repository: ${REPO}"
                        def repoDir = "repo-${REPO.hashCode()}"

                        // Fetch all remote branches
                        def branches = sh(script: "git -C ${repoDir} branch -r", returnStdout: true).trim().split("\n")
                        echo "Fetched branches: ${branches}"

                        // Example condition for archiving: branches with "feature" in the name
                        // Example condition for deletion: branches older than a certain date or marked as "obsolete"
                        def commitDate = sh(script: "git -C ${repoDir} log -1 --format=%cd origin/main", returnStdout: true).trim()
                        def sdf = new java.text.SimpleDateFormat("EEE MMM dd HH:mm:ss yyyy Z")
                        def parsedDate = sdf.parse(commitDate)

                        branches.each { branch ->
                            def cleanBranchName = branch.replaceAll("origin/", "").trim()

                            // Archiving condition
                            if (cleanBranchName.contains("feature")) {
                                archiveBranches.add(cleanBranchName)
                            }

                            // Deletion condition: branches older than a certain date or with "obsolete" in the name
                            if (cleanBranchName.contains("obsolete") || isOlderThan(parsedDate, cleanBranchName, repoDir)) {
                                deleteBranches.add(cleanBranchName)
                            }
                        }
                    }

                    // Set the archive and delete lists to environment variables
                    env.BRANCHES_TO_ARCHIVE = archiveBranches.join(', ')
                    env.BRANCHES_TO_DELETE = deleteBranches.join(', ')

                    echo "Branches to archive: ${env.BRANCHES_TO_ARCHIVE}"
                    echo "Branches to delete: ${env.BRANCHES_TO_DELETE}"
                }
            }
        }

        stage('Notify Teams') {
            steps {
                script {
                    // Send email notifications about the branches to archive or delete
                    emailext(
                        subject: "Branches to Archive/Remove",
                        body: "Following branches need to be archived: ${env.BRANCHES_TO_ARCHIVE}\n\n" +
                              "Following branches are identified for deletion: ${env.BRANCHES_TO_DELETE}",
                        to: "navaneetha.22june@gmail.com"  // Replace with actual recipient email(s)
                    )
                }
            }
        }

        stage('Archive Branches') {
            when {
                expression { return env.BRANCHES_TO_ARCHIVE != '' }
            }
            steps {
                script {
                    def branchesToArchive = env.BRANCHES_TO_ARCHIVE.split(', ')
                    branchesToArchive.each { branch ->
                        // Add archiving logic here (e.g., create a tag, zip the branch content, etc.)
                        echo "Archiving branch: ${branch}"
                        // Example of tagging the branch before archiving
                        REPOS.each { REPO ->
                            def repoDir = "repo-${REPO.hashCode()}"
                            sh "git -C ${repoDir} checkout ${branch}"
                            sh "git -C ${repoDir} tag archived-${branch}"
                        }
                    }
                }
            }
        }

        stage('Delete Branches') {
            when {
                expression { return env.BRANCHES_TO_DELETE != '' }
            }
            steps {
                script {
                    def branchesToDelete = env.BRANCHES_TO_DELETE.split(', ')
                    branchesToDelete.each { branch ->
                        // Add deletion logic here (e.g., delete the branch from the remote)
                        echo "Deleting branch: ${branch}"
                        REPOS.each { REPO ->
                            def repoDir = "repo-${REPO.hashCode()}"
                            sh "git -C ${repoDir} push origin --delete ${branch}"
                        }
                    }
                }
            }
        }
    }
}

// Helper function to check if a branch is older than a given date
def isOlderThan(Date commitDate, String branch, String repoDir) {
    // Example logic to check if a branch is older than a specific date
    def branchDate = sh(script: "git -C ${repoDir} log -1 --format=%cd origin/${branch}", returnStdout: true).trim()
    def sdf = new java.text.SimpleDateFormat("EEE MMM dd HH:mm:ss yyyy Z")
    def parsedBranchDate = sdf.parse(branchDate)

    // Compare commit date with branch date
    return parsedBranchDate.before(commitDate)
}

        GIT_CREDENTIALS = 'github-automation'
    }

    stages {
        stage('Checkout SCM') {
            steps {
                script {
                    echo 'Checking out the repository'
                    checkout scm
                }
            }
        }

        stage('Verify Git Branches') {
            steps {
                script {
                    echo 'Fetching all remote branches'
                    sh 'git fetch --all'
                    def branches = sh(script: 'git branch -r', returnStdout: true).trim().split("\n")
                    echo "Fetched branches: ${branches}"

                    // Initialize counters for archived and deleted branches
                    def archivedCount = 0
                    def deletedCount = 0

                    // For each branch, check the commit date
                    for (branch in branches) {
                        if (branch.startsWith("origin/")) {
                            def branchName = branch.replace("origin/", "")
                            echo "Checking branch: ${branchName}"
                            def lastCommitDate = sh(script: "git log -1 --format=%cd ${branch}", returnStdout: true).trim()
                            echo "Last commit date for ${branchName}: ${lastCommitDate}"

                            // Add any logic for deciding whether to delete or archive the branch
                            // Example: Check if branch is older than 30 days (you can customize this)
                            def lastCommitTime = Date.parse("yyyy-MM-dd", lastCommitDate)
                            def currentTime = new Date()
                            def diffInDays = (currentTime - lastCommitTime) / (1000 * 60 * 60 * 24)
                            if (diffInDays > 30) {
                                echo "Branch ${branchName} is older than 30 days and will be deleted"
                                // Simulate branch deletion (for real deletion, use git or GitHub API)
                                deletedCount++
                                // Delete the branch (Uncomment this if you want to actually delete it)
                                // sh "git push origin --delete ${branchName}"
                            } else {
                                echo "Branch ${branchName} is still active and will be archived"
                                archivedCount++
                                // Add logic for archiving the branch (e.g., moving the branch to an archive folder)
                            }
                        }
                    }

                    // Set the variables so they can be used in email notification
                    currentBuild.description = "Archived: ${archivedCount}, Deleted: ${deletedCount}"
                }
            }
        }
    }

    post {
        always {
            echo 'Cleaning up workspace'
            cleanWs()
        }
        success {
            echo 'Pipeline completed successfully'
        }
        failure {
            echo 'Pipeline failed, check logs for details'
        }

        // Send email notification after the pipeline is complete
        always {
            script {
                emailext (
                    subject: "Jenkins Pipeline: ${currentBuild.fullDisplayName} - ${currentBuild.result}",
                    body: """
                        The Jenkins pipeline ${currentBuild.fullDisplayName} has finished with result: ${currentBuild.result}.
                        
                        Number of branches archived: ${archivedCount}
                        Number of branches deleted: ${deletedCount}
                        
                        Please check the logs for details.
                    """,
                    to: "navaneetha.22june@gmail.com" // Replace with your actual email address
                )
            }
        }
    }
}
