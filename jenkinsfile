pipeline {
    agent any

    environment {
        GIT_CREDENTIALS = 'github-automation'  // GitHub credentials ID in Jenkins
        REPOS = [
            'https://github.com/Nava200/branch-automation.git', 
            'https://github.com/Nava200/Getting-Started-Terraform.git'
        ]  // List of repositories
        BRANCHES_TO_ARCHIVE = ''
        BRANCHES_TO_DELETE = ''
    }

    stages {
        stage('Checkout Repositories') {
            steps {
                script {
                    REPOS.each { REPO ->
                        echo "Cloning repository: ${REPO}"
                        dir("repo-${REPO.hashCode()}") {
                            checkout scm: [
                                $class: 'GitSCM',
                                branches: [[name: 'origin/main']],
                                userRemoteConfigs: [[url: REPO, credentialsId: GIT_CREDENTIALS]]
                            ]
                        }
                    }
                }
            }
        }

        stage('Identify Branches to Archive/Delete') {
            steps {
                script {
                    def archiveBranches = []
                    def deleteBranches = []

                    REPOS.each { REPO ->
                        def repoDir = "repo-${REPO.hashCode()}"
                        def branches = sh(script: "git -C ${repoDir} branch -r", returnStdout: true).trim().split("\n")

                        branches.each { branch ->
                            def cleanBranchName = branch.replace("origin/", "").trim()

                            // Archiving condition: If branch contains "feature"
                            if (cleanBranchName.contains("feature")) {
                                archiveBranches.add(cleanBranchName)
                            }

                            // Deletion condition: If branch is older than 30 days
                            def commitDate = sh(script: "git -C ${repoDir} log -1 --format=%cd origin/${branch}", returnStdout: true).trim()
                            def sdf = new java.text.SimpleDateFormat("EEE MMM dd HH:mm:ss yyyy Z")
                            def parsedDate = sdf.parse(commitDate)
                            def currentDate = new Date()
                            def diffInDays = (currentDate - parsedDate) / (1000 * 60 * 60 * 24)

                            if (diffInDays > 30) {
                                deleteBranches.add(cleanBranchName)
                            }
                        }
                    }

                    env.BRANCHES_TO_ARCHIVE = archiveBranches.join(', ')
                    env.BRANCHES_TO_DELETE = deleteBranches.join(', ')

                    echo "Branches to archive: ${env.BRANCHES_TO_ARCHIVE}"
                    echo "Branches to delete: ${env.BRANCHES_TO_DELETE}"
                }
            }
        }

        stage('Notify Teams') {
            steps {
                script {
                    emailext(
                        subject: "Branches to Archive/Delete",
                        body: "Branches to archive: ${env.BRANCHES_TO_ARCHIVE}\nBranches to delete: ${env.BRANCHES_TO_DELETE}",
                        to: "navaneetha.22june@gmail.com"  // Replace with actual email(s)
                    )
                }
            }
        }

        stage('Archive Branches') {
            when {
                expression { return env.BRANCHES_TO_ARCHIVE != '' }
            }
            steps {
                script {
                    def branchesToArchive = env.BRANCHES_TO_ARCHIVE.split(', ')
                    branchesToArchive.each { branch ->
                        echo "Archiving branch: ${branch}"
                        REPOS.each { REPO ->
                            def repoDir = "repo-${REPO.hashCode()}"
                            sh "git -C ${repoDir} checkout ${branch}"
                            sh "git -C ${repoDir} tag archived-${branch}"
                        }
                    }
                }
            }
        }

        stage('Delete Branches') {
            when {
                expression { return env.BRANCHES_TO_DELETE != '' }
            }
            steps {
                script {
                    def branchesToDelete = env.BRANCHES_TO_DELETE.split(', ')
                    branchesToDelete.each { branch ->
                        echo "Deleting branch: ${branch}"
                        REPOS.each { REPO ->
                            def repoDir = "repo-${REPO.hashCode()}"
                            sh "git -C ${repoDir} push origin --delete ${branch}"
                        }
                    }
                }
            }
        }
    }

    post {
        always {
            cleanWs()
        }
        success {
            echo 'Pipeline completed successfully'
        }
        failure {
            echo 'Pipeline failed, check logs for details'
        }
    }
}
